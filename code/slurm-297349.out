Thu Mar  2 17:03:34 2023       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 465.19.01    Driver Version: 465.19.01    CUDA Version: 11.3     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  NVIDIA GeForce ...  On   | 00000000:01:00.0 Off |                  N/A |
| 38%   35C    P8    32W / 350W |      1MiB / 24268MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
|   1  NVIDIA GeForce ...  On   | 00000000:25:00.0 Off |                  N/A |
| 38%   35C    P8    20W / 350W |      1MiB / 24268MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
|   2  NVIDIA GeForce ...  On   | 00000000:41:00.0 Off |                  N/A |
| 39%   35C    P8    21W / 350W |      1MiB / 24268MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
|   3  NVIDIA GeForce ...  On   | 00000000:61:00.0 Off |                  N/A |
| 38%   34C    P8    20W / 350W |      1MiB / 24268MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2022 NVIDIA Corporation
Built on Wed_Jun__8_16:49:14_PDT_2022
Cuda compilation tools, release 11.7, V11.7.99
Build cuda_11.7.r11.7/compiler.31442593_0
Source: desc Target: python
Data path: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/
Pre-trained model: Salesforce/codet5-base
Model type: codet5
Experiment name: codet5_nl_pl_program
TEST_FILE_SRC: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt TEST_FILE_TGT: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
03/02/2023 17:03:38 - INFO - __main__ -   Namespace(adam_epsilon=1e-08, beam_size=5, config_name='Salesforce/codet5-base', dev_filename=None, do_eval=False, do_lower_case=False, do_test=True, do_train=False, eval_batch_size=16, eval_steps=-1, gradient_accumulation_steps=1, learning_rate=5e-05, load_model_path='/home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin', local_rank=-1, max_grad_norm=1.0, max_source_length=400, max_steps=-1, max_target_length=400, model_name_or_path='Salesforce/codet5-base', model_type='codet5', no_cuda=False, num_train_epochs=3.0, output_dir='/home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python', seed=42, test_filename='/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py', tokenizer_name='Salesforce/codet5-base', train_batch_size=8, train_filename=None, train_steps=-1, warmup_steps=0, weight_decay=0.0)
03/02/2023 17:03:38 - WARNING - __main__ -   Process rank: -1, device: cuda, n_gpu: 1, distributed training: False
03/02/2023 17:03:47 - INFO - __main__ -   reload model from /home/ysnamgoong42/ws/XLCoST/code/../codet5_nl_pl_program/desc-Python/checkpoint-best-ppl/pytorch_model.bin
03/02/2023 17:03:52 - INFO - __main__ -   Test file: /home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.txt,/home/ysnamgoong42/ws/XLCoST/g4g/XLCoST_data/pair_data_tok_full_desc_comment/Python-desc/test-Python-desc-tok.py
T5ForConditionalGeneration :  /home/ysnamgoong42/miniconda3/envs/xlcost/lib/python3.8/site-packages/transformers/models/t5/modeling_t5.py
  0%|          | 0/56 [00:00<?, ?it/s]  2%|▏         | 1/56 [00:12<11:42, 12.77s/it]  4%|▎         | 2/56 [00:29<13:49, 15.36s/it]  5%|▌         | 3/56 [00:45<13:39, 15.46s/it]  7%|▋         | 4/56 [01:03<14:06, 16.28s/it]  9%|▉         | 5/56 [01:22<14:44, 17.35s/it] 11%|█         | 6/56 [01:41<15:02, 18.05s/it] 12%|█▎        | 7/56 [02:04<15:55, 19.50s/it] 14%|█▍        | 8/56 [02:28<16:46, 20.96s/it] 16%|█▌        | 9/56 [02:54<17:49, 22.75s/it] 18%|█▊        | 10/56 [03:22<18:36, 24.28s/it] 20%|█▉        | 11/56 [03:52<19:26, 25.93s/it] 21%|██▏       | 12/56 [04:23<20:09, 27.48s/it] 23%|██▎       | 13/56 [04:56<20:50, 29.08s/it] 25%|██▌       | 14/56 [05:31<21:36, 30.88s/it] 27%|██▋       | 15/56 [06:07<22:18, 32.65s/it] 29%|██▊       | 16/56 [06:44<22:30, 33.77s/it] 30%|███       | 17/56 [07:24<23:08, 35.59s/it] 32%|███▏      | 18/56 [08:06<23:46, 37.53s/it] 34%|███▍      | 19/56 [08:50<24:21, 39.51s/it] 36%|███▌      | 20/56 [09:35<24:47, 41.32s/it] 38%|███▊      | 21/56 [10:23<25:12, 43.21s/it] 39%|███▉      | 22/56 [11:09<24:55, 43.97s/it] 41%|████      | 23/56 [11:59<25:13, 45.87s/it] 43%|████▎     | 24/56 [12:51<25:28, 47.78s/it] 45%|████▍     | 25/56 [13:45<25:38, 49.64s/it] 46%|████▋     | 26/56 [14:41<25:40, 51.34s/it] 48%|████▊     | 27/56 [15:38<25:41, 53.14s/it] 50%|█████     | 28/56 [16:37<25:37, 54.92s/it] 52%|█████▏    | 29/56 [17:36<25:12, 56.03s/it] 54%|█████▎    | 30/56 [18:38<25:05, 57.89s/it] 55%|█████▌    | 31/56 [19:41<24:47, 59.48s/it] 57%|█████▋    | 32/56 [20:47<24:36, 61.50s/it] 59%|█████▉    | 33/56 [21:56<24:22, 63.61s/it] 61%|██████    | 34/56 [23:05<23:55, 65.23s/it] 62%|██████▎   | 35/56 [24:16<23:30, 67.17s/it] 64%|██████▍   | 36/56 [25:29<22:55, 68.75s/it] 66%|██████▌   | 37/56 [26:45<22:26, 70.89s/it] 68%|██████▊   | 38/56 [28:02<21:47, 72.65s/it] 70%|██████▉   | 39/56 [29:20<21:07, 74.54s/it] 71%|███████▏  | 40/56 [30:41<20:19, 76.19s/it] 73%|███████▎  | 41/56 [32:01<19:20, 77.35s/it] 75%|███████▌  | 42/56 [33:24<18:27, 79.13s/it] 77%|███████▋  | 43/56 [34:49<17:33, 81.02s/it] 79%|███████▊  | 44/56 [36:16<16:33, 82.81s/it] 80%|████████  | 45/56 [37:45<15:30, 84.59s/it] 82%|████████▏ | 46/56 [39:12<14:13, 85.37s/it] 84%|████████▍ | 47/56 [40:42<12:59, 86.58s/it] 86%|████████▌ | 48/56 [42:13<11:44, 88.07s/it] 88%|████████▊ | 49/56 [43:47<10:28, 89.76s/it] 89%|████████▉ | 50/56 [45:22<09:07, 91.27s/it] 91%|█████████ | 51/56 [46:58<07:44, 92.94s/it] 93%|█████████▎| 52/56 [48:37<06:18, 94.58s/it] 95%|█████████▍| 53/56 [50:17<04:48, 96.21s/it] 96%|█████████▋| 54/56 [52:00<03:16, 98.21s/it] 98%|█████████▊| 55/56 [53:43<01:39, 99.70s/it]100%|██████████| 56/56 [55:23<00:00, 99.91s/it]100%|██████████| 56/56 [55:23<00:00, 59.35s/it]
03/02/2023 17:59:17 - INFO - __main__ -     bleu-4 = 39.25 
03/02/2023 17:59:17 - INFO - __main__ -     xMatch = 0.0 
03/02/2023 17:59:17 - INFO - __main__ -     ********************
tokenizer.decode(top_preds[0]): def findMinSum ( arr , N ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE mp [ arr [ j ] ] += 1 NEW_LINE DEDENT sum = min ( sum , mp [ arr [ i ] ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMinSum ( arr , N ) ) NEW_LINE
tokenizer.decode(top_preds[0]): import math NEW_LINE def binaryToBinary ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , int ( math . log2 ( n ) ) + 1 ) : NEW_LINE INDENT arr [ i ] = int ( math . log2 ( n % 2 ) + 1 ) NEW_LINE DEDENT return arr NEW_LINE DEDENT def binaryToDecimal ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = int ( arr [ i ] ) NEW_LINE DEDENT return arr NEW_LINE DEDENT def concatenate ( a , b , k ) : NEW_LINE INDENT n = binaryToBinary ( a ) NEW_LINE n = binaryToBinary ( b ) NEW_LINE k = int ( math . log2 ( k ) + 1 ) NEW_LINE a = binaryToBinary ( a ) NEW_LINE b = binaryToBinary ( b ) NEW_LINE if ( n < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 ] * ( k + 1 ) NEW_LINE b = [ 0 ] * ( k + 1 ) NEW_LINE print ( concatenate ( a , b , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): import math NEW_LINE def convert ( N ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( N > 0 ) : NEW_LINE INDENT v . append ( int ( N % 10 ) ) NEW_LINE N //= 10 NEW_LINE DEDENT if ( N == 0 ) : NEW_LINE INDENT return [ ] NEW_LINE DEDENT v . reverse ( ) NEW_LINE v . append ( 0 ) NEW_LINE v . reverse ( ) NEW_LINE v . reverse ( ) NEW_LINE v . reverse ( ) NEW_LINE return v NEW_LINE DEDENT def countNumbers ( A , B , C ) : NEW_LINE INDENT v = convert ( A [ 0 ] ) NEW_LINE if ( len ( v ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT v = convert ( v [ : : - 1 ] ) NEW_LINE lower = [ 0 for i in range ( len ( v ) ) ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] == 0 ) : NEW_LINE INDENT lower [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT lower [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] == 0 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT return lower [ B - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE B = len ( A ) NEW_LINE C = 2 NEW_LINE print ( countNumbers
tokenizer.decode(top_preds[0]): def isValid ( time ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( len ( time ) ) : NEW_LINE INDENT if ( time [ i ] == ' ? ' ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT def isValid ( time , L , R ) : NEW_LINE INDENT hour = abs ( time - L ) NEW_LINE minute = abs ( time - R ) NEW_LINE flag = 0 NEW_LINE for i in range ( len ( time ) ) : NEW_LINE INDENT if ( isValid ( time [ i ] ) ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT def findTime ( time , L , R ) : NEW_LINE INDENT hour = abs ( time - L ) NEW_LINE minute = abs ( time - R ) NEW_LINE if ( isValid ( hour ) ) : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 23 , 59 NEW_LINE findTime ( time , L , R ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): import math NEW_LINE def maxIntersections ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT circles = math . sqrt ( x1 * x2 + y1 * y2 ) NEW_LINE straightlines = math . sqrt ( x1 * x2 + y1 * y2 ) NEW_LINE return max ( circles , straightlines ) NEW_LINE DEDENT x1 = 3 NEW_LINE y1 = 4 NEW_LINE print ( maxIntersections ( x1 , y1 , x2 , y2 ) ) NEW_LINE
tokenizer.decode(top_preds[0]): def isUdulating ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 10 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12345 NEW_LINE if ( isUdulating ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0]): import math NEW_LINE def findKthSetBit ( n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) + 1 NEW_LINE return math . floor ( math . log2 ( n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( findKthSetBit ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def leftRotate ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT DEDENT def rightRotate ( arr , n , d ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i - d ] NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def smallestMissing ( arr , n ) : NEW_LINE INDENT low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid ] == 0 ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestMissing ( arr , n ) ) NEW_LINE
tokenizer.decode(top_preds[0]): MAX_CHAR = 256 NEW_LINE dp = [ [ [ - 1 for x in range ( MAX_CHAR ) ] for y in range ( MAX_CHAR ) ] for z in range ( MAX_CHAR ) ] NEW_LINE def lcs ( str1 , str2 , i , j ) : NEW_LINE INDENT if ( i > len1 or j > len2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT return lcs ( str1 , str2 , i + 1 , j ) NEW_LINE DEDENT else : NEW_LINE INDENT return lcs ( str1 , str2 , i + 1 , j ) NEW_LINE DEDENT DEDENT def printLCS ( str1 , str2 , lcslen ) : NEW_LINE INDENT currlcs = lcslen NEW_LINE if ( currlcs == lcslen ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT def printLCS ( str1 , str2 ) : NEW_LINE INDENT len1 =
tokenizer.decode(top_preds[0]): def numberOfWays ( n ) : NEW_LINE INDENT fac1 = ( n - 1 ) ; NEW_LINE fac2 = ( n - 1 ) ; NEW_LINE fac3 = ( n - 2 ) ; NEW_LINE fac4 = ( n - 3 ) ; NEW_LINE fac5 = ( n - 4 ) ; NEW_LINE fac6 = ( n - 5 ) ; NEW_LINE ways = fac1 * fac2 ; NEW_LINE print ( ways ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE numberOfWays ( n ) ; NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modExp ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def isComposite ( n , d , k ) : NEW_LINE INDENT if ( n > 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = random . randint ( 2 , n - 2 ) NEW_LINE x = ( a * x ) % n NEW_LINE while ( d > 0 ) : NEW_LINE INDENT x = ( x * x ) % n NEW_LINE d = d >> 1 NEW_LINE x = ( x * x ) % n NEW_LINE DEDENT return isComposite ( n , d , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 3 NEW_LINE if ( isComposite ( n , k ) ) : NEW_LINE INDENT print ( " Composite " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ composite " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0]): def countTriplets ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT mp [ A [ i ] & A [ j ] ] += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( mp [ A [ i ] & A [ j ] ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE print ( countTriplets ( A , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): import math NEW_LINE def areaOfSector ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT area = math . sqrt ( x1 * x2 + y1 * y2 ) NEW_LINE return area NEW_LINE DEDENT x1 = 1 NEW_LINE y1 = 2 NEW_LINE x2 = 3 NEW_LINE y2 = 4 NEW_LINE print ( " Area ▁ of ▁ the ▁ Circular ▁ Sector : ▁ " , areaOfSector ( x1 , y1 , x2 , y2 ) ) NEW_LINE
tokenizer.decode(top_preds[0]): def findMinSwaps ( N , P ) : NEW_LINE INDENT new_arr = [ 0 ] * ( N + 1 ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT new_arr [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( P [ i ] [ 0 ] == ' X ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( P [ i ] [ 0 ] == ' X ' ) : NEW_LINE INDENT new_arr [ i ] = new_arr [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT new_arr [ i ] = new_arr [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT N = 3 NEW_LINE P = [ 1 , 2 , 3 ] NEW_LINE findMinSwaps ( N , P ) NEW_LINE
tokenizer.decode(top_preds[0]): def lis ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT lis ( arr , j ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT lis ( arr , i , j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def findLIS ( arr , n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE DEDENT return lis ( arr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLIS ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def seriesSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def sortArray ( arr , n , a , b ) : NEW_LINE INDENT start = a NEW_LINE end = b NEW_LINE arr . sort ( ) NEW_LINE for i in range ( a , end + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE sortArray ( arr , n , a , b ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def maxSquare ( a , b , c ) : NEW_LINE INDENT return ( a * b + c * c ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE c = 5 NEW_LINE print ( maxSquare ( a , b , c ) ) NEW_LINE
tokenizer.decode(top_preds[0]): n = 4 NEW_LINE m = 4 NEW_LINE def countSets ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == '1' ) : NEW_LINE INDENT ans += n * m NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE print ( countSets ( mat ) ) NEW_LINE
tokenizer.decode(top_preds[0]): def pathCountDPRecDP ( m , n , k ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT return pathCountDPRecDP ( m - 1 , n , k ) + pathCountDPRecDP ( m - 1 , n - 1 , k ) NEW_LINE DEDENT else : NEW_LINE INDENT return pathCountDPRecDP ( m - 1 , n - 1 , k ) NEW_LINE DEDENT DEDENT def pathCountDP ( m , n , k ) : NEW_LINE INDENT return pathCountDPRecDP ( m , n , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 5 NEW_LINE k = 2 NEW_LINE print ( " Number ▁ of ▁ paths ▁ with ▁ exactly ▁ " , " coins ▁ = ▁ " , k , " ▁ = ▁ " , pathCountDP ( m , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def addNumbers ( x , y ) : NEW_LINE INDENT carry = 0 NEW_LINE while ( carry != 0 ) : NEW_LINE INDENT x = x ^ carry NEW_LINE carry = carry >> 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT sum = sum + x NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE y = 10 NEW_LINE print ( addNumbers ( x , y ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def findPrefixXOR ( L , R ) : NEW_LINE INDENT pre = [ 0 ] * ( L + 1 ) NEW_LINE for i in range ( 1 , R + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] ^ pre [ i - 2 ] NEW_LINE DEDENT for i in range ( 1 , L + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] ^ pre [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , R + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] ^ pre [ i - 1 ] NEW_LINE DEDENT return pre [ R ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 2 NEW_LINE print ( findPrefixXOR ( L , R ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def reverseArray ( arr , s , e ) : NEW_LINE INDENT for i in range ( s , e + 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i ] , arr [ i + 1 ] NEW_LINE DEDENT DEDENT def generateRotations ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE generateRotations ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def maximumABs ( s , n ) : NEW_LINE INDENT A = 0 NEW_LINE B = 0 NEW_LINE AB = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' A ' and s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT A += 1 NEW_LINE B += 1 NEW_LINE DEDENT else : NEW_LINE INDENT AB += 1 NEW_LINE DEDENT DEDENT ans = AB NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' B ' and s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT B += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( s [ i ] == ' A ' and s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT else : NEW_LINE INDENT A += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " AABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBBABBBABBBABBABBABB
tokenizer.decode(top_preds[0]): def longestSubsequence ( arr , n ) : NEW_LINE INDENT for x in range ( n ) : NEW_LINE INDENT arr [ x ] = arr [ x - 1 ] NEW_LINE x -= 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE longestSubsequence ( arr , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def countSubsets ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < k ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( countSubsets ( arr , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( countPairs ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def possible ( A , B , n , x , y ) : NEW_LINE INDENT if ( n < x or n < y ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( A [ n - 1 ] < B [ n - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( possible ( A , B , n , x , y ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def minimumOperations ( arr , N ) : NEW_LINE INDENT prefix_sum = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i ] + arr [ i ] NEW_LINE DEDENT max_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( prefix_sum [ j ] == prefix_sum [ i ] ) : NEW_LINE INDENT group_sum [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT group_sum [ i ] -= 1 NEW_LINE DEDENT DEDENT max_sum = max ( max_sum , group_sum [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minimumOperations ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def printRightShifts ( A , N ) : NEW_LINE INDENT shifts = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT shifts += 1 NEW_LINE DEDENT DEDENT print ( shifts ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( A ) NEW_LINE printRightShifts ( A , N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): from collections import defaultdict NEW_LINE def smallestString ( s ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 2 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT elif ( mp [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 2 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( smallestString ( s ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): from collections import defaultdict NEW_LINE def check ( sm1 , sm2 , sm3 , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( sm1 == - 1 or sm2 == - 1 or sm3 == - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( sm1 [ i ] + sm2 [ j ] == sm3 [ j ] + sm1 [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT def partitionArray ( arr , n ) : NEW_LINE INDENT sm1 = defaultdict ( lambda : 0 ) NEW_LINE sm2 = defaultdict ( lambda : 0 ) NEW_LINE sm2 = defaultdict ( lambda : 0 ) NEW_LINE sm3 = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm1 [ i ] += arr [ i ] NEW_LINE sm2 [ i ] += arr [ i ] NEW_LINE DEDENT sm3 [ n ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm3 [ i ] += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( sm1 [ i ] + sm2 [ i ] == sm3 [ i ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( partitionArray ( arr ,
tokenizer.decode(top_preds[0]): def maxSubArraySum ( a , n , k ) : NEW_LINE INDENT maxSubArraySum = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT maxSubArraySum = max ( maxSubArraySum , a [ i ] + a [ i + 1 ] ) NEW_LINE DEDENT return maxSubArraySum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( maxSubArraySum ( a , n , k ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def printPalindrome ( S ) : NEW_LINE INDENT Hash = { } NEW_LINE for ch in S : NEW_LINE INDENT Hash [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for ch in range ( ' a ' , ' z ' ) : NEW_LINE INDENT if ( Hash [ ch ] == 2 ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT DEDENT for i in range ( ' a ' , ' z ' ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT if ( Hash [ i ] >= 3 ) : NEW_LINE INDENT for j in range ( ' a ' , ' z ' ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT DEDENT for i in range ( ' a ' , ' z ' ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT for i in range ( ' a ' , ' z ' ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT for i in range ( ' a ' , ' z ' ) : NEW_LINE INDENT for j in range ( ' a ' , ' z ' ) : NEW_LINE INDENT if ( Hash [ j ] > 0 ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT DEDENT for i in range ( ' a ' , ' z ' ) : NEW_LINE INDENT st . add ( ch ) NEW_LINE DEDENT print ( st ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = " geeksforgeeks " NEW_LINE printPalindrome ( S ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): from collections import defaultdict NEW_LINE def encrypt ( s , x ) : NEW_LINE INDENT n = len ( s ) NEW_LINE x = x // 26 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( ' a ' ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( encrypt ( s , x ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def countWords ( str ) : NEW_LINE INDENT a = str . split ( " ▁ " ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " Geeks ▁ for ▁ Geeks " NEW_LINE print ( countWords ( str ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def circleArea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 2 * r * r ) NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( circleArea ( r ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def findSubset ( N ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + 1 NEW_LINE DEDENT minDiff = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( count [ i ] == 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , count [ i ] - count [ i - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( count [ i ] == 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , count [ i ] - count [ i - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( count [ i ] == 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , count [ i ] - count [ i - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( minDiff , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE findSubset ( N ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): import math NEW_LINE def productOfPairs ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product *= ( arr [ i ] * arr [ j ] ) NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productOfPairs ( arr , n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def isPossible ( x , y ) : NEW_LINE INDENT if ( x == 0 and y == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE isPossible ( x , y ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def checkPoint ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT if ( x1 >= x2 and y1 >= y3 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( x1 >= x2 and y1 >= y3 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 >= x3 and y1 >= y3 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( x1 >= x2 and y1 <= y3 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT elif ( x1 >= x3 and y1 >= y3 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( x1 >= x3 and y1 <= y3 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 1 NEW_LINE y1 = 2 NEW_LINE x2 = 2 NEW_LINE y2 = 3 NEW_LINE x3 = 2 NEW_LINE y3 = 3 NEW_LINE x4 = 2 NEW_LINE y4 = 2 NEW_LINE x5 = 2 NEW_LINE y5 = 2 NEW_LINE x4 = 2 NEW_LINE y4 = 2 NEW_LINE if ( checkPoint ( x1 , y1 , x2 , y3 , x4 , y4 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0]): def maxSubarraySum ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( K == 1 ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE print ( maxSubarraySum ( arr , N , K ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): from math import sqrt NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT if ( sum >= n ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE K = 2 NEW_LINE getSum ( N ) NEW_LINE if ( getSum ( N ) >= N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0]): from math import log2 NEW_LINE def compare ( x , y ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 ) NEW_LINE dp [ 0 ] = x NEW_LINE dp [ 1 ] = y NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT for j in range ( 2 , y + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 5 NEW_LINE y = 3 NEW_LINE print ( compare ( x , y ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def printQuery ( arr , n , queries ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( queries ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE queries = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 2 , 3 ] ] NEW_LINE printQuery ( arr , n , queries ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def arePermutations ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum += arr1 [ i ] NEW_LINE mul *= arr2 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum += arr1 [ i ] NEW_LINE mul *= arr2 [ i ] NEW_LINE DEDENT if ( sum == mul ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 , 4 ] NEW_LINE arr2 = [ 2 , 3 , 4 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE if arePermutations ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0]): def average ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT return sum / n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( average ( n ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def countPairs ( arr , N ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE freq = [ 0 ] * ( max_element + 1 ) NEW_LINE for i in range ( 1 , max_element + 1 ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT pairs = 0 NEW_LINE for i in range ( 1 , max_element + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , max_element + 1 ) : NEW_LINE INDENT if ( freq [ j ] > 1 ) : NEW_LINE INDENT pairs += 1 NEW_LINE DEDENT DEDENT DEDENT return pairs NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( countPairs ( arr , N ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def minOperations ( m , n ) : NEW_LINE INDENT if ( m < n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " + 1" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " * 2" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( m // 2 ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE INDENT print ( m // 2 ) NEW_LINE return NEW_LINE DEDENT if ( m % 2 == 0 and n % 2 == 0 ) : NEW_LINE
tokenizer.decode(top_preds[0]): import math NEW_LINE def reverseDigits ( num ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + ( num % 10 ) NEW_LINE num = num // 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 12345 NEW_LINE print ( reverseDigits ( num ) ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def isEqual ( arr1 , arr2 ) : NEW_LINE INDENT return ( arr1 [ 0 ] == arr2 [ 0 ] ) NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT countP = [ 0 ] * 26 NEW_LINE countTW = [ 0 ] * 26 NEW_LINE for i in range ( len ( pat ) ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT countTW [ ord ( txt [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( isEqual ( countP [ i ] , countTW [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT pat = " geeksforgeeks " NEW_LINE txt = " geeksforgeeks " NEW_LINE if ( search ( pat , txt ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
tokenizer.decode(top_preds[0]): import math NEW_LINE def countDiagonal ( n ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * n * n * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countDiagonal ( n ) ) NEW_LINE
tokenizer.decode(top_preds[0]): def kthSubString ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( k > n ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += s [ i ] NEW_LINE if ( k > sum ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += s [ i ] NEW_LINE sum = sum + s [ i - 1 ] NEW_LINE DEDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( s [ mid ] == s [ mid + 1 ] ) : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT print ( s [ start : mid + 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE k = 2 NEW_LINE kthSubString ( s , k ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT str1 = str ( arr1 [ i ] ) NEW_LINE str2 = str ( arr2 [ i ] ) NEW_LINE if ( str1 < str2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr1 ) NEW_LINE printArr ( arr1 , n ) NEW_LINE DEDENT
tokenizer.decode(top_preds[0]): def minDiff ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT min = min ( min , arr [ i ] ) NEW_LINE max = max ( max , arr [ i ] ) NEW_LINE DEDENT return min NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minDiff ( arr , n ) ) NEW_LINE
usage: evaluator.py [-h] [--references REFERENCES] [--predictions PREDICTIONS]
evaluator.py: error: unrecognized arguments:  
run_NL_PL.sh: line 202: --references: command not found
usage: calc_code_bleu.py [-h] --refs REFS [REFS ...] --hyp HYP --lang
                         {java,javascript,c_sharp,php,go,python,cpp,c,ruby}
                         [--params PARAMS]
calc_code_bleu.py: error: the following arguments are required: --refs, --hyp, --lang
run_NL_PL.sh: line 208: --ref: command not found
